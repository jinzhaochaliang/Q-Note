# 树

---


1.  重建二叉树
	>前序遍历 preorder = [3,9,20,15,7]
	>中序遍历 inorder = [9,3,15,20,7]
	
	```
	TreeNode* create(int prel,int prer,int inl,int inr,vector<int>& pre,vector<int>& in){
        if(prel>prer) return NULL;
        TreeNode* root = new TreeNode(pre[prel]);
        int k;
        for(k=inl;k<=inr;k++){
            if(in[k]==pre[prel]) break;
        } 
        int numleft = k-inl;
        root->left = create(prel+1,prel+numleft,inl,k-1,pre,in);
        root->right = create(prel+numleft+1,prer,k+1,inr,pre,in);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder,vector<int>& inorder){
        return create(0,preorder.size()-1,0,inorder.size()-1,preorder,inorder);
    }
	```
1.  二叉树的下一个结点
	>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
	
	```
	TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(!pNode) return nullptr;
        if(pNode->right){
            TreeLinkNode *tmp = pNode->right;
            while(tmp->left){
                tmp = tmp->left;
            }
            return tmp;
        }
        TreeLinkNode *tmp = pNode;
        while(tmp->next&&tmp->next->left!=tmp){
            tmp = tmp->next;
        }
        if(!tmp->next){
            return nullptr;
        }else{
            return tmp->next;
        }
    }
	```
1.  树的子结构
	>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)    B是A的子结构， 即A中有出现和B相同的结构和节点值。
	
	```
	bool dfs(TreeNode* A,TreeNode* B){
        if(!B) return true;
        if(!A) return false;
        if(A->val!=B->val) return false;
        return dfs(A->left,B->left)&&dfs(A->right,B->right);
    }
    bool isSubStructure(TreeNode* A,TreeNode* B){
        if(!A||!B) return false;
        if(A->val==B->val) return dfs(A,B);
        return isSubStructure(A->left,B)||isSubStructure(A->right,B);
    } 
	```
1.  序列化二叉树
	>请实现两个函数，分别用来序列化和反序列化二叉树。
	>
	>[1,9,2,8,10]
	>
	>1,9,8,#,#,10,#,#,2,#,#
	
	```
    // Encodes a tree to a single string.
	string serialize(TreeNode* root) {
        if(!root) return "#";
        string s = to_string(root->val)+","+serialize(root->left)+","+serialize(root->right);
        cout<<s<<endl;
        return s;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int num = 0;
        return Decodes(data,num);
    }
    TreeNode* Decodes(string &data,int &num){
        if(data[num]=='#'){
            num += 2;
            return nullptr;
        }
        bool judge = false;
        if(data[num]=='-'){
            num++;
            judge = true;
        }
        int d = 0;
        while(data[num]!=','){
            d = d*10+data[num]-'0';
            num++;
        } 
        if(judge) d *= -1; 
        TreeNode* root = new TreeNode(d);
        num++;
        root->left = Decodes(data,num);
        root->right = Decodes(data,num);
        return root;
    } 
	```