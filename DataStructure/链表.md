# 链表

---

* 从尾到头打印链表
	```
	void r(ListNode* head,vector<int>& res){
	    if(head==NULL) return;
	    r(head->next,res);
	    res.push_back(head->val);
	}
	vector<int> reversePrint(ListNode* head){
	    vector<int> res;
	    r(head,res);
	    return res;
	}
	```

* 回文链表
	```
	bool isPalindrome(ListNode* head) {
	    ListNode *fast=head,*slow=head;
	    while(fast&&fast->next){
	        fast = fast->next->next;
	        slow = slow->next;
	    }
	    //后半部分链表反转
	    ListNode *res = nullptr;
	    while(slow){
	        ListNode *tmp = slow->next;
	        slow->next = res;
	        res = slow;
	        slow = tmp;
	    }
	    while(head&&res){
	        if(head->val!=res->val){
	            return false;
	        }
	        head = head->next;
	        res = res->next;
	    }
	    return true;
	}
	```

* 链表中倒数第k个节点
	```
	ListNode* getKthFromEnd(ListNode* head,int& k){
	    if(!head) return nullptr;
	    ListNode *fast=head,*slow=head;k--;
	    while(fast->next&&k){
	        fast = fast->next;
	        k--;
	    }
	    if(k>0) return nullptr;
	    while(fast->next){
	        fast = fast->next;
	        slow = slow->next;
	    }
	    return slow;
	}
	```

* 删除链表的倒数第N个节点
	```
	ListNode* removeNthFromEnd(ListNode* head, int n) {
	    if(!head) return nullptr;
	    ListNode *fast=head,*slow=head;
	    while(n){
	        fast = fast->next;
	        n--;
	    }
	    if(!fast){
	        ListNode *tmp = head->next;
	        delete head;
	        return tmp;
	    }
	    while(fast->next){
	        fast = fast->next;
	        slow = slow->next;
	    }
	    ListNode* tmp = slow->next->next;
	    delete slow->next;
	    slow->next = tmp;
	    return head;
	}
	```

* 链表的中间节点
	```
	ListNode* middleNode(ListNode* head) {
	    ListNode *fast=head,*slow=head;
	    while(fast&&fast->next){
	        fast = fast->next->next;
	        slow = slow->next;
	    }
	    return slow;
	}
	```

* 判断链表是否有环
	```
	bool hasCycle(ListNode *head) {
	    if(!head||!head->next) return false;
	    ListNode *slow = head, *fast=head->next;
	    while(fast!=slow){
	        if(!fast->next||!fast->next->next) return false;
	        slow = slow->next;
	        fast = fast->next->next;
	    }
	    return true;
	}
	```

* 链表中环的入口节点

    >给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
 
	```
	ListNode* EntryNodeOfLoop(ListNode* head)
	{
	    if(!head||!head->next) return nullptr;
	    ListNode *fast=head,*slow=head;
	    while(fast&&fast->next){
	        slow = slow->next;
	        fast = fast->next->next;
	        if(slow==fast){
	            slow = head;
	            while(slow!=fast){
	                slow = slow->next;
	                fast = fast->next;
	            }
	            return slow;
	        }
	    }
	    return nullptr;
	}
	```

* 删除链表中的节点
	```
	void deleteNode(ListNode* node) {
	    ListNode *tmp = node->next;
	    node->val = tmp->val;
	    node->next = tmp->next;
	    delete tmp;
	}
	```

* 删除链表中等于给定值的所有节点
	>输入: 1->2->6->3->4->5->6, val = 6
	>
	>输出: 1->2->3->4->5
	
	```
	ListNode* removeElements(ListNode* head, int val) {
	    ListNode pre(-1);
	    pre.next = head;
	    ListNode *cur = &pre;
	    while(cur->next){
	        if(cur->next->val==val){
	            ListNode *tmp = cur->next;
	            cur->next = tmp->next;
	            delete tmp;
	        }else{
	            cur = cur->next;
	        }
	    }
	    return pre.next;
	}
	```

* 删除有序表中的重复节点
	>输入: 1->1->2->3->3
	>
	>输出: 1->2->3
	
	```
	ListNode* deleteDuplicates(ListNode* head) {
	    if(!head) return head;
	    ListNode *cur = head;
	    while(cur->next){
	        if(cur->val==cur->next->val){
	            ListNode *tmp = cur->next;
	            cur->next = tmp->next;
	            delete tmp;
	        }else{
	            cur = cur->next;
	        }
	    }
	    return head;
	}
	```
* 删除排序链表中的重复元素 II
	>输入: 1->2->3->3->4->4->5
	>
	>输出: 1->2->5
	
	```
	ListNode* deleteDuplicates(ListNode* head) {
        ListNode *cur = new ListNode(0);
        cur->next = head;
        ListNode *pre = cur;
        while(cur->next){
            ListNode *p = cur->next,*tmp;
            while(p->next&&p->next->val==p->val){
                tmp = p;
                p = p->next;
                delete tmp;
            }
            if(cur->next!=p){
                cur->next = p->next;
                delete p;
            }else{
                cur = cur->next;
            }
        }
        return pre->next;
    }
	```

* 反转链表
	>输入: 1->2->3->4->5->NULL
	>
	>输出: 5->4->3->2->1->NULL
	
	```
	ListNode* reverseList(ListNode* head) {
        ListNode* prenode = NULL;
        ListNode* node = head;
        while(node){
            ListNode* temp = node->next;
            node->next = prenode;
            prenode = node;
            node = temp;
        }
        return prenode;
    }
	```

* 反转链表
	>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
	
	```
	Node* copyRandomList(Node* head) {
        if(!head) return nullptr;
        unordered_map<Node*,Node*> mp;
        for(Node* it=head;it;it=it->next){
            mp[it] = new Node(it->val);
        }
        for(Node* it=head;it;it=it->next){
            if(it->next) mp[it]->next = mp[it->next];
            if(it->random) mp[it]->random = mp[it->random];
        }
        return mp[head];
    }
	```

* 旋转链表
	>输入: 1->2->3->4->5->NULL, k = 2
	>
    >输出: 4->5->1->2->3->NULL
	
	```
	Node* copyRandomList(Node* head) {
        if(!head) return nullptr;
        unordered_map<Node*,Node*> mp;
        for(Node* it=head;it;it=it->next){
            mp[it] = new Node(it->val);
        }
        for(Node* it=head;it;it=it->next){
            if(it->next) mp[it]->next = mp[it->next];
            if(it->random) mp[it]->random = mp[it->random];
        }
        return mp[head];
    }
	```