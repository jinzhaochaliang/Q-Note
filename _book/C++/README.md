# C++

1. C和C++的区别

   1. C是结构化语言，重点在于算法和数据结构。考虑如何通过一个过程，来解决问题
   2. C++首要考虑是如何构造一个对象模型，让这个模型去配合对应的问题
   3. 面向对象是一门哲学，它通过对语言建模来适应问题，而不是对问题建模以适应语言

2. static关键字的作用

   1. 函数体内的static变量作用范围为该函数体，该变量内存只被分配一次。
   2. 模块内的static全局变量只能被模块内的函数访问，模块外无法访问
   3. 模块内的static函数只能被模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
   4. 在类中static成员变量属于整个类所有，对类的所有对象只有一份拷贝
   5. 在类中static成员函数属于整个类所有，所以不接收this指针，因此只能访问类的static成员变量。static在静态区分配，而this指针指向堆区。

3. const关键字的作用

   1. 常变量

      ```cpp
      const 类型 变量名
      ```

      声明必须初始化

   2. 常指针

      ```cpp
      const char* p;  //指向*p 值无法修改，但可以改变指向
      char* const p;  //指向p  值可以修改，但无法改变指向
      ```

   3. 常引用

      ```cpp
      const 类型 &引用
      ```

   4. 常对象

      ```cpp
      类名 const 对象名
      ```

      const对象只能访问const的成员函数，非const对象可以访问任意函数

   5. 常成员函数

      ```cpp
      类名::fun(形参) const
      ```

4. extern关键字的作用

   1. extern修饰变量的声明

   2. extern修饰函数的声明

   3. extern指示C/C++函数的调用规范

      ```cpp
      extern "C" //表示C++程序中要调用的C库函数
      ```

5. volatile的作用

   1. 易变性。下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。
   2. 不可优化性。保证程序员写在代码中的指令一定会执行。
   3. 顺序性。保证volatile变量间的顺序，编译器不会进行乱序优化。

6. C++11特性

   1. nullptr替代NULL

   2. 类型推导

      1. auto类型推导 变量
      2. decltype类型推导 表达式

   3. 区间迭代 

      ```cpp
      for(auto &i : arr)
      ```

   4. 初始化列表

   5. Lambda表达式

7. 左值引用与右值引用

   1. 左值和右值的区别在于能否获取地址

   2. 左值引用与右值引用

      1. 传统的C++引用被称为左值引用

         ```cpp
         int i = 10;
         int &ii = i;
         ```

         汇编：将1赋值给i，将i的地址放入eax，将eax的值传给ii

      2. C++11新增了右值引用，右值引用关联到右值时，右值被存储到特定的位置，右值引用指向该特定位置

         ```cpp
         int && iii = 10;
         ```

         汇编：将10赋值给eax，将eax放入临时变量的地址，将该地址放入eax，将eax的值传给iii

      3. const左值引用

         ```cpp
         const int & i = 10
         ```

         如果是一个const的左值引用，是可以绑定到右值上的

      4. 根据右值引用的语法，不能将右值引用绑定到一个左值上

         ```cpp
         int && iii = move(ii)
         ```

         使用move函数可以完成操作

8. 指针和引用的区别

   1. 引用不能为空，指针可以为空
   2. 引用一旦初始化不能改变指向，而指针可以改变
   3. 引用比指针更安全

9. 指针传递，值传递，引用传递

   1. 指针传递：传递的是地址值
   2. 值传递：在栈中开辟内存，存放由主调函数放进来的实参变量。对形参的任何操作都是作为局部变量进行的，不会影响主调函数实参变量的值
   3. 引用传递：在栈中开辟内存，存放由主调函数放进来的实参变量的地址
   4. 指针传递与引用传递的不同：引用传递被调函数对形参的任何操作都被处理为间接寻址，指针传递如果改变指针地址，影响不到主调函数的相关变量。

10. new和malloc的区别

    	1. 对于非内部数据结构的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时自动执行构造函数，对象消亡之前自动执行析构函数。
     	2. malloc是库函数，new是运算符

 11. 大小端的判断

      1. 利用union判断，union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。

      2. ```
         int checkCPU(){
         	union w{
         		int a;
         		char b;
         	}c;
         	c.a = 1;
         	return (c.b==1); //小端为1，大端为0
         }
         ```

12. C++面向对象的三大特性

    1. 封装：将客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    2. 继承：让某个类型的对象获得另一个类型对象的属性的方法。分为实现继承和接口继承
    3. 多态：一个类实例的相同方法在不同情形有不同的表现形式

13. 多态性与虚函数

    1. 多态

       1. 静态多态：编译时的多态，通过重载实现
       2. 动态多态：运行时的多态，通过虚函数实现

    2. 虚函数

       1. 一个父类声明virtual，其子类函数不管有没有声明为virtual，都是虚函数
       2. 父类指针指向子类对象：既可以使用子类强大的功能，又可以抽取父类的共性。注意public基础

    3. 纯虚函数

       很多情况下基类生成对象是不合情理的，纯虚函数只定义函数体，没有实现过程，相当于接口，不能直接实例化。

    4. 构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时必须声明为虚函数。

       1. 构造函数不能声明为虚函数的原因

          构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。虚函数的执行依赖于虚函数表，而虚函数表在构造函数中进行初始化。

14. C++中overload，override，overwrite的区别

    1. overload重载

       在C++中可以将语义，功能相似的几个函数用同一个名字表示，但参数或返回值不同。

    2. override覆盖

       派生类函数覆盖基类函数，函数名字相同，参数相同，基类函数必须有virtual关键字

    3. overwrite重写

       派生类函数屏蔽了与其同名的基类函数，参数不一定相同，注意与覆盖的区别。

15. 智能指针

    1. share_ptr

       多个智能指针可以共享同一个对象

    2. weak_ptr

    3. unique_ptr

    4. auto_ptr

16. 四种类型转换

    1. static_cast

       静态类型转换

    2. dynamic_cast

       动态类型转换，如子类和父类之间多态类型的转换

       **基类必须有虚函数，保持多态特性才能使用dynamic_cast**

       ```cpp
       BaseClass *pb2 = new BaseClass();
       DClass *p3 = static_cast<DClass*>(pb2); //父类->子类，错误，访问子类对象越界
       DClass *p4 = dynamic_cast<DClass*>(pb2); //父类->子类，安全，结果为NULL
       ```

    3. const_cast

       去除const类型

    4. reinterpreter_cast

       不同类型的指针类型转换，从底层对数据进行重新解释，危险操作

17. 内存对齐的原则

18. 内联函数与宏定义

19. 深拷贝与浅拷贝的区别

    1. 浅拷贝

       对一个已知对象进行拷贝，会自动调用拷贝构造函数。若用户自己未定义，则会调用默认拷贝构造函数。调用一次构造函数，调用两次析构函数，两个对象的指针成员所指内存相同，但是程序结束时该内存却被释放了两次，会造成内存泄漏。

    2. 深拷贝

       在对含有指针成员的对象进行拷贝时，必须要自定义拷贝构造函数。

    3. 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后指针是指向两个不同地址的指针。

20. 栈和堆的区别

    1. 申请方式
       1. 栈：由编译器自动管理，无需手动控制。声明函数中的一个局部变量时，系统自动在栈中为变量开辟空间。在调用一个函数时，系统自动给函数的形参变量开辟空间。
       2. 堆：申请和释放由程序员自己控制，并指明大小。容易产生内存泄漏。
       3. 什么是内存泄漏（memory leak）？ 指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。
    2. 申请后系统的响应
       1. 栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则报异常栈溢出
       2. 堆：当系统收到程序的申请，会遍历记录空闲内存地址的链表，寻找到第一个空间大于所申请空间的堆结点，然后将该节点从链表中删除，并将该结点空间分配给程序。
    3. 申请大小的限制
       1. 栈：栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的
       2. 堆：堆是向高地址扩展的数据结构，是不连续的区域。
    4. 分配效率
       1. 栈是机器系统提供的数据结构，计算机在底层对栈提供支持，分配专门的寄存器存放栈的地址。压栈出栈都有专门的指令，这就决定了栈的效率比较高。
       2. 堆是C/C++库函数提供的，一般速度比较慢，而且容易产生内存碎片。
    5. 栈快捷，自由度小。堆麻烦，自由度大。

21. RAII机制

    > 作者：zhaozhengcoder
    > 链接：https://www.jianshu.com/p/b7ffe79498be

    1. 什么是RAII？

       RAII是Resource Acquisition Is Initialization（“资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

    2. 为什么要使用RAII？

       如果程序很复杂的时候，需要将所有的new 分配的内存delete掉，会导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。

    3. 如何使用RAII？
       当我们在一个函数内部使用局部变量，退出了这个局部变量的作用域时，这个变量也就被销毁了；当这个变量是类对象时，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显式的去调用完成。RAII就是这样去完成的。

       由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。

       ```cpp
       #include <iostream> 
       using namespace std; 
       
       class ArrayOperation 
       { 
       public : 
           ArrayOperation() 
           { 
               m_Array = new int [10]; 
           } 
       
           void InitArray() 
           { 
               for (int i = 0; i < 10; ++i) 
               { 
                   *(m_Array + i) = i; 
               } 
           } 
       
           void ShowArray() 
           { 
               for (int i = 0; i <10; ++i) 
               { 
                   cout<<m_Array[i]<<endl; 
               } 
           } 
       
           ~ArrayOperation() 
           { 
               cout<< "~ArrayOperation is called" <<endl; 
               if (m_Array != NULL ) 
               { 
                   delete[] m_Array;
                   m_Array = NULL ; 
               } 
           } 
       
       private : 
           int *m_Array; 
       }; 
       
       int main() 
       { 
           ArrayOperation arrayOp; 
           arrayOp.InitArray(); 
           arrayOp.ShowArray(); 
           return 0;
       }
       ```

       RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理。理解和使用RAII能使软件设计更清晰，代码更健壮。

22.  C++源代码到可执行文件的详细过程

    1. 编译预处理

       参数-e，生成一个没有宏定义，没有条件编译指令，没有特殊符号的文件

    2. 编译阶段

       将预处理文件生成相应的汇编代码

    3. 汇编阶段

       将汇编语言代码翻译成目标机器指令的过程

    4. 链接阶段

       静态链接和动态链接

23. STL相关

24.  vector的实现原理

    1. vector维护一个连续的线性空间
    2. vector动态增加大小，并不是在原空间之后增加新空间，而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后在原内容之后构造新元素，并释放原空间。

25.  手写strcpy，memcpy，strcat，strcmp函数

    1. strcpy只能复制字符串，memcpy可以复制任何内容。strcpy不需要指定长度，memcpy第三个参数指定长度。