# Database

1. 事务
   1. 事务是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。
      1. 数据库中的undo、rollback，既撤消和回滚。首先这2个操作是针对事务来说的。
         举一个简单的例子，A给B转账，在数据库中就需要给A,B进行update操作。这2条sql语句必须都执行或者都不执行(称为一个事务)。假如先执行B的update语句，B的金额增加了100，然后执行A的update语句，A的金额减100。如果A的余额大于100，那么2个语句没问题，但是A的余额小于100时，再减100就变成负的了，这不符合实际情况。所以第二条sql就出现无法执行，那么数据库的状态必须回到没有执行B的update语句之前。
         当一个事务执行的时候，数据库会依次执行中间的sql语句，当某一条sql发生错误以后，根据事务的原子性，通过2种方式使数据库回到事务没有执行的状态。撤销就是相当于不执行commit;回滚就是执行一遍相反的操作，比如再执行B的update金额减100。
   2. ACID
      1. 原子性（Atomicity）
         1. 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚
      2. 一致性（Consistency）
         1. 数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果都是相同的
      3. 隔离性（Isolation）
         1. 一个事务所做的修改在最终提交以前，对其他事务是不可见的
      4. 持久性（Durability）
         1. 一旦事务提交，则其所做的修改将会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失
      5. 联系
         1. 只有满足一致性，事务的执行结果才是正确的
         2. 在无并发的情况下，事务串行执行，隔离性一定能满足。此时只要满足原子性，就一定能满足一致性
         3. 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性才能满足一致性
         4. 事务满足持久性是为能应对系统崩溃的情况
2. 并发一致性问题
   1. 丢失修改
      1. T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改
   2. 读脏数据
      1. T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读到的数据是脏数据
   3. 不可重复读
      1. T2读取一个数据，T1将其修改，T2再次读取这个数据，两次读取结果不同
   4. 幻影读
      1. T1读取某个范围内的数据，T2在这个范围内插入新数据，T1再次读取这个范围内的数据，此时读取的结果和第一次读取的结果不同

3. 封锁
   1. 封锁粒度
      1. 行级锁
      2. 表级锁
      3. 加锁需要消耗资源，锁的各种操作都会增加系统开销。因此封锁粒度越小，系统的开销就越大
      
   2. 读写锁
      1. 互斥锁，X锁，写锁
      2. 共享锁，S锁，读锁
      3. 加了X锁不能再加其他锁，加了S锁可以再加S锁
      
   3. 意向锁
      1. 在读写锁的基础上引入IX/IS锁，两个都是表锁
      2. IX，表示事务想要在某个数据行加上X锁
      3. 一个事务在获得某个数据行对象X锁之前，必须先获得IX锁
      4. 任意IS/IX锁之间相互兼容
      
   4. 封锁协议
      
      1. 三级封锁协议
         1. 事务T要修改数据A时必须加X锁，直到T结束才释放锁，解决（丢失修改问题）
         2. 在一级的基础上，要求读取数据A时必须加S锁，读完马上释放S锁，解决（读脏数据问题）
         3. 在二级的基础上，要求读取数据A时必须加S锁，直到事务结束才能释放S锁，解决（不可重复读问题）
      2. 两端锁协议
         1. 加锁和解锁分为两个阶段进行
      
   5. 隔离级别
   
      1. 未提交读：事务中的修改，即使没有提交，对其他事务也是可见的
      2. 提交读：一个事务只能读取已经提交的事务所做的修改
      3. 可重复读：保证同一个事务中多次读取同一数据的结果是一样的
      4. 可串行化：强制事务串行执行，这样多个事务互不干扰
   
   6. 范式
   
      1. 第一范式：属性不可分
   
      2. 第二范式：每个非主属性完全函数依赖与键码
   
         | Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
         | ---- | ------ | ------ | ------ | ------ | ----- |
         | 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
         | 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
         | 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
         | 3    | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |
   
         以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：
   
         - Sno -> Sname, Sdept
         - Sdept -> Mname
         - Sno, Cname-> Grade
   
         Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。
   
         Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。
   
         **分解后** 
   
         关系-1
   
         | Sno  | Sname  | Sdept  | Mname  |
         | ---- | ------ | ------ | ------ |
         | 1    | 学生-1 | 学院-1 | 院长-1 |
         | 2    | 学生-2 | 学院-2 | 院长-2 |
         | 3    | 学生-3 | 学院-2 | 院长-2 |
   
         有以下函数依赖：
   
         - Sno -> Sname, Sdept
         - Sdept -> Mname
   
         关系-2
   
         | Sno  | Cname  | Grade |
         | ---- | ------ | ----- |
         | 1    | 课程-1 | 90    |
         | 2    | 课程-2 | 80    |
         | 2    | 课程-1 | 100   |
         | 3    | 课程-2 | 95    |
   
         有以下函数依赖：
   
         - Sno, Cname -> Grade
   
      3. 第三范式：非主属性不传递函数依赖于键码。
   
         上面的 关系-1 中存在以下传递函数依赖：
   
         | Sno  | Sname  | Sdept  | Mname  |
         | ---- | ------ | ------ | ------ |
         | 1    | 学生-1 | 学院-1 | 院长-1 |
         | 2    | 学生-2 | 学院-2 | 院长-2 |
         | 3    | 学生-3 | 学院-2 | 院长-2 |
   
         - Sno -> Sdept -> Mname
   
         可以进行以下分解：
   
         关系-11
   
         | Sno  | Sname  | Sdept  |
         | ---- | ------ | ------ |
         | 1    | 学生-1 | 学院-1 |
         | 2    | 学生-2 | 学院-2 |
         | 3    | 学生-3 | 学院-2 |
   
         关系-12
   
         | Sdept  | Mname  |
         | ------ | ------ |
         | 学院-1 | 院长-1 |
         | 学院-2 | 院长-2 |
   
         

