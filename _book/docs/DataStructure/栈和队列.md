# 栈和队列

---


1.  用栈实现队列
	>使用栈实现队列的下列操作：

	>* push(x) -- 将一个元素放入队列的尾部。
	>* pop() -- 从队列首部移除元素。
	>* peek() -- 返回队列首部的元素。
	>* empty() -- 返回队列是否为空。

	```
	class MyQueue {
	public:
	    /** Initialize your data structure here. */
	    MyQueue() {
	    }
	    /** Push element x to the back of queue. */
	    void push(int x) {
	        st1.push(x);
	    }
	    /** Removes the element from in front of queue and returns that element. */
	    int pop() {
	        if(st2.empty()){
	            while(!st1.empty()){
	                st2.push(st1.top());
	                st1.pop();
	            }
	        }
	        int res = st2.top();
	        st2.pop();
	        return res;
	    }
	    /** Get the front element. */
	    int peek() {
	        if(!st2.empty()){
	            return st2.top();
	        }else{
	            while(!st1.empty()){
	                st2.push(st1.top());
	                st1.pop();
	            }
	        }
	        return st2.top();
	    }
	    /** Returns whether the queue is empty. */
	    bool empty() {
	        return st1.empty()&&st2.empty();
	    }
	private:
	    stack<int> st1,st2;
	};
	```
1.  用队列实现栈
	>使用队列实现栈的下列操作：

	>* push(x) -- 元素 x 入栈
	>* pop() -- 移除栈顶元素
	>* top() -- 获取栈顶元素
	>* empty() -- 返回栈是否为空

	```
	class MyStack {
	public:
	    /** Initialize your data structure here. */
	    MyStack() {
	    }
	    /** Push element x onto stack. */
	    void push(int x) {
	        int size = q.size();
	        q.push(x);
	        while(size--){
	            int temp = q.front();
	            q.pop();
	            q.push(temp);
	        }
	    }
	    /** Removes the element on top of the stack and returns that element. */
	    int pop() {
	        int temp = q.front();
	        q.pop();
	        return temp;
	    }
	    /** Get the top element. */
	    int top() {
	        return q.front();
	    }
	    /** Returns whether the stack is empty. */
	    bool empty() {
	        return q.empty();
	    }
	private:
	    queue<int> q;
	};
	```
1.  包含min函数的栈
	>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

	```
	class MinStack {
	public:
	    /** initialize your data structure here. */
	    MinStack() {
	    }
	    void push(int x) {
	        s1.push(x);
	        if(s2.empty()||x<=s2.top()){
	        	s2.push(x);
			}
	    }
	    void pop() {
	    	if(s1.top()==s2.top()){
	    		s2.pop();
			}
	        return s1.pop();
	    }
	    int top() {
	        return s1.top();
	    }
	    int min() {
	        return s2.top();
	    }
	private:
		stack<int> s1,s2;
	};
	```